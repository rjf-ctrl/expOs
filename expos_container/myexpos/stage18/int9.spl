//setting mode flag to exec system call no.
alias CurProcess R0;
CurProcess = PROCESS_TABLE + 16 * [SYSTEM_STATUS_TABLE + 1];

//storing user SP to UPTR
[CurProcess + 13] = SP;
alias userSP R2;
userSP = SP;

//setting SP to kernel stack
SP = [CurProcess + 11] * 512 - 1;

//set mode flag
[CurProcess + 9] = 9;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//get fileName from stack
alias fname R1;
fname = [[PTBR + 2 * ((userSP - 4) / 512)] * 512 + ((userSP - 4) % 512)];

//search memory copy of inode table for the file
R4 = 0;
while(R4 < MAX_FILE_NUM) do
    if([INODE_TABLE + R4 * 16 + 1] == fname && [INODE_TABLE + R4 * 16] == 3) then
        break;
    endif;
    R4 = R4 + 1;
endwhile;

//If file not found, return -1
if(R4 >= MAX_FILE_NUM) then
    [[PTBR + 2 * ((userSP - 1) / 512)] * 512 + ((userSP - 1) % 512)] = -1;
    [CurProcess + 9] = 0;   //reset MODE FLAG
    SP = 8 * 512;
    ireturn;
endif;

//File found and is XEXE - R4 holds the inode index


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//Call Exit Process (Module 1 - process manager, Function 3)
//free resources
multipush(R0, R1, R2, R3, R4);
R1 = 3;                 //EXIT_PROCESS function number
R2 = [SYSTEM_STATUS_TABLE + 1];
call MOD_1;
multipop(R0, R1, R2, R3, R4);


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//reclaim the user area page
//exit process freed it but we need it back

//increment memfreelist
[MEMORY_FREE_LIST + [CurProcess + 11]] = 1;

//increment MEM_FREE_COUNT in system status table
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;

//initialise new kernel stack
SP = [CurProcess + 11] * 512 - 1;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//update process table - new process
[CurProcess + 4] = RUNNING;    //STATE
[CurProcess + 7] = R4;         //INODE INDEX

//set up page table entries for new process
//(i) library pages
[PTBR + 0] = 63;
[PTBR + 1] = "0100";
[PTBR + 2] = 64;
[PTBR + 3] = "0100";

//(ii) heap pages - logical pages 2 & 3
multipush(R1, R2, R3, R4);
R1 = 1;      //GET_FREE_PAGE function number
call MOD_2;  //Memory Manager
multipop(R1, R2, R3, R4);
[PTBR + 4] = R0;
[PTBR + 5] = "0110";

multipush(R1, R2, R3, R4);
R1 = 1;
call MOD_2;
multipop(R1, R2, R3, R4);
[PTBR + 6] = R0;
[PTBR + 7] = "0110";

//(iii) stack pages - logical pages 8 & 9
multipush(R1, R2, R3, R4);
R1 = 1;
call MOD_2;
multipop(R1, R2, R3, R4);
[PTBR + 16] = R0;
[PTBR + 17] = "0110";

multipush(R1, R2, R3, R4);
R1 = 1;
call MOD_2;
multipop(R1, R2, R3, R4);
[PTBR + 18] = R0;
[PTBR + 19] = "0110";

//(iv) code pages - calculate number of pages needed from file size
R2 = ([INODE_TABLE + R4 * 16 + 2] + 511) / 512;    //ceil(file size / 512)
R3 = 0;

//allocate pages and load blocks via disk manager (Module 4)
while(R2 > R3) do
    multipush(R1, R2, R3, R4);
    R1 = 1;         //GET_FREE_PAGE function number
    call MOD_2;
    multipop(R1, R2, R3, R4);
    [PTBR + 2 * R3 + 8] = R0;
    [PTBR + 2 * R3 + 9] = "0100";

    //invoke disk load (Module 4 - Device Manager) instead of loadi
    R1 = [INODE_TABLE + R4 * 16 + 8 + R3];
    multipush(R1, R2, R3, R4);
    R4 = R1;        //disk block number
    R1 = 2;         //DISK_LOAD function number
    R2 = [SYSTEM_STATUS_TABLE + 1];
    R3 = R0;        //page to load into
    call MOD_4;
    multipop(R1, R2, R3, R4);

    R3 = R3 + 1;
endwhile;

//(v) mark remaining code page table entries as invalid
while(4 > R3) do
    [PTBR + 2 * R3 + 8] = -1;
    [PTBR + 2 * R3 + 9] = "0000";
    R3 = R3 + 1;
endwhile;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//initialise per-process resource table entries to -1
alias index R1;
index = 0;
while(index < 16) do
    [[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 11] * 512 + RESOURCE_TABLE_OFFSET + index] = -1;
    index = index + 2;
endwhile;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//entry point IP - stored at word 1 of first code page
[[PTBR + 16] * 512] = [[PTBR + 8] * 512 + 1];

//user stack pointer
SP = 8 * 512;

//reset MODE FLAG
[CurProcess + 9] = 0;

ireturn;