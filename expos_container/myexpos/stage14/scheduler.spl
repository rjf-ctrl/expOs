//Saving Process Table of currently running Process

//identify currently running process
alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE+1];

//save BP 
SP = SP+1;
[SP]=BP;

//locate process_table base address
alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1] * 16;

//save offset of KPTR
[process_table_entry + 12] = SP % 512;
[process_table_entry + 14] = PTBR;
[process_table_entry + 15] = PTLR;



//----------------------------------------------------------------------------------------------------------------------------------
alias newPID  R4;
newPID = (currentPID + 1) % 16;
while (newPID != currentPID) do
	if([PROCESS_TABLE + newPID * 16 + 4] == READY || [PROCESS_TABLE + newPID*16 + 4] == CREATED) then
		print "scheduled";
		break;
	endif;
	newPID = (newPID + 1) % 16;
endwhile;

//------------------------------------------------------------------------------------------------------------------------------------

//switch to new process_table_base
alias new_process_table R3;
new_process_table = PROCESS_TABLE + newPID * 16;

//Set back Kernel SP, PTBR , PTLR
//Kernel SP = UAPN * 512 + KPTR offset
SP =  [new_process_table + 11] * 512 + [new_process_table + 12] ;
PTBR = [new_process_table + 14];
PTLR = [new_process_table + 15];

//set new process 
[SYSTEM_STATUS_TABLE + 1] = newPID;

//special case: first execution of process
if([new_process_table + 4] == CREATED) then
	[new_process_table + 4] = RUNNING;
	[new_process_table + 9] = 0;
	SP = [new_process_table + 13];
	ireturn;
endif;

[new_process_table + 4] = RUNNING;

//-------------------------------------------------------------------------------------------------------------------------------------------------

BP = [SP];
SP=SP-1;
//print "byescheduler";
return;