//setting mode to exec system call no.
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16 ) + 9] = 9;

alias currentPID R4;
currentPID = [SYSTEM_STATUS_TABLE + 1];

//storing user SP to UPTR
[PROCESS_TABLE + (currentPID * 16) + 13] = SP;

//setting SP to kernel stack
SP = [PROCESS_TABLE + (currentPID * 16) + 11] * 512 - 1;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//get fileName from stack
alias userSP R5;
alias fileName R6;
alias flag R7;
alias i R8;
alias inodeI R9;

userSP = [PROCESS_TABLE + (currentPID * 16) + 13];
fileName = [[PTBR + 2 * ((userSP - 4) / 512)] * 512 + ((userSP - 4) % 512)];


//search memory copy of inode table for the file
flag = 0;
i = 0;
while(i < MAX_FILE_NUM) do
    if([INODE_TABLE + i * 16 + 1] == fileName && [INODE_TABLE + i * 16 + 0] == EXEC) then
        inodeI = i;
        flag = 1;
        break;
    endif;
    i = i + 1;
endwhile;

//If file not found or not XEXE type, return -1
if(flag == 0) then
    [[PTBR + 2 * ((userSP - 1) / 512)] * 512 + ((userSP - 1) % 512)] = -1;
    SP = [PROCESS_TABLE + (currentPID * 16) + 13];
    [PROCESS_TABLE + (currentPID * 16) + 9] = 0;   //reset MODE FLAG
    ireturn; //return to usermode
endif;

//File found and is XEXE - inodeI holds the inode index


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//Call Exit Process (Module 1 - process manager, Function 3)
//free resources
multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9);
R1 = 3;                 //EXIT_PROCESS function number
R2 = currentPID;
call MOD_1;
multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9);


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//reclaim the user area page
//exit process freed it but we need it back
alias userAreaPage R10;
userAreaPage = [PROCESS_TABLE + (currentPID * 16) + 11];

//increment memfreelist
[MEMORY_FREE_LIST + userAreaPage] = [MEMORY_FREE_LIST + userAreaPage] + 1;

//decrement MEM_FREE_COUNT in system status table
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;

//initialise new kernel stack
SP = userAreaPage * 512 - 1;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//update process table - new process
[PROCESS_TABLE + (currentPID * 16) + 4] = RUNNING;    //STATE
[PROCESS_TABLE + (currentPID * 16) + 7] = inodeI;     //INODE INDEX

//set up page table entries for new process
//(i) library pages
[PTBR + 0] = 63;
[PTBR + 1] = "0100";
[PTBR + 2] = 64;
[PTBR + 3] = "0100";

//(ii) heap pages - logical pages 2 & 3
multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10);
R1 = 1;      //GET_FREE_PAGE function number
call MOD_2;  //Memory Manager
[PTBR + 4] = R0;
[PTBR + 5] = "0110";
multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10);

multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10);
R1 = 1;
call MOD_2;
[PTBR + 6] = R0;
[PTBR + 7] = "0110";
multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10);

//(iii) stack pages - logical pages 8 & 9
multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R12);
R1 = 1;
call MOD_2;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";
multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R12);

multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R12);
R1 = 1;
call MOD_2;
[PTBR + 18] = R0;
[PTBR + 19] = "0110";
multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R12);

//(iv) code pages - allocate only for blocks that exist in inode table
alias blk_cnt R11;
blk_cnt = 0;
i = 0;
while(i < 4) do
    if([INODE_TABLE + (inodeI * 16) + 8 + i] != -1) then
        //block exists - allocate a free page
        blk_cnt = blk_cnt + 1;
        multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12);
        R1 = 1;         //GET_FREE_PAGE function number
        call MOD_2;
        [PTBR + 8 + 2 * i] = R0;
        [PTBR + 9 + 2 * i] = "0100";
        multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12);
    else
        //no block - mark page table entry invalid
        [PTBR + 8 + 2 * i] = -1;
        [PTBR + 9 + 2 * i] = "0000";
    endif;
    i = i + 1;
endwhile;

//(v) code pages - load blocks into allocated pages
i = 0;
while(i < 4) do
    if([INODE_TABLE + (inodeI * 16) + 8 + i] != -1) then
        loadi([PTBR + 8 + 2 * i], [INODE_TABLE + (inodeI * 16) + 8 + i]);
    endif;
    i = i + 1;
endwhile;


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------


//entry point IP - stored at word 1 of first code page
alias stackTop R12;
stackTop = [PTBR + 16];
[stackTop * 512] = [[PTBR + 8] * 512 + 1];

//user stack pointer
SP = 8 * 512;

//reset MODE FLAG
[PROCESS_TABLE + currentPID * 16 + 9] = 0;

ireturn;