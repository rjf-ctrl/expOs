// Module 2 - Memory Manager

alias functionNum R1;

// 1 = Get Free Page
// 2 = Release Page

if(functionNum == 1) then
    
    //increment WAIT_MEM_COUNT 
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;
    
    //while memory is full (MEM_FREE_COUNT == 0)
    while([SYSTEM_STATUS_TABLE + 2] == 0) do
        //set state to WAIT_MEM of current process
        [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 4] = WAIT_MEM;
        
        //context switch
        multipush(R1);
        call MOD_5;   
        multipop(R1);
    endwhile;
    
    //decrement WAIT_MEM_COUNT and MEM_FREE_COUNT
    [SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;
    [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
    
    //find free page in memfreelist
    alias i R2;
    i = 0;
    while(i < MAX_MEM_PAGE) do
        if([MEMORY_FREE_LIST + i] == 0) then
            [MEMORY_FREE_LIST + i] = 1;
            R0 = i;     // return free page number in R0
            break;
        endif;
        i = i + 1;
    endwhile;
    
    return;
endif;


if(functionNum == 2) then

    //page number to release is in R2
    alias pageNum R2;
    
    //decrement memfreelist
    [MEMORY_FREE_LIST + pageNum] = [MEMORY_FREE_LIST + pageNum] - 1;
    
    // If entry == 0, page is free - increment MEM_FREE_COUNT
    if([MEMORY_FREE_LIST + pageNum] == 0) then
        [SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
    endif;
    
    //all processes waiting for memory (WAIT_MEM -> READY)
    alias j R3;
    j = 0;
    while(j < MAX_PROC_NUM) do
        if([PROCESS_TABLE + (j * 16) + 4] == WAIT_MEM) then
            [PROCESS_TABLE + (j * 16) + 4] = READY;
        endif;
        j = j + 1;
    endwhile;
    
    return;
endif;